%Paulin VIOLETTE
%Si t'as pas bossé sur l'interface utilisateur t'y touche pas.
%Sauf si la personne dont le nom est écris en haut te dis d'y toucher.
%Deso Paulin moi j'y ai touché
\chapter{Interface Utilisateur}

\section{Présentation}

%Mettre l'image de ma super interface grave stylé
\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{./img/frontend/example1.png}
  \caption{Interface utilisateur en utilisation}
  \label{}
\end{figure}

Une fois l'utilisateur connecté, il est redirgigé vers l'interface de l'application : un éditeur de texte et une console.
L'interface est divisée en quatre parties :
\begin{itemize}
  \item La barre de navigation, contenant les liens vers les autres parties du site (gestion de compte...)
  \item La barre d'outils, qui contient des contrôles spécifiques à l'application
  \item L'editeur, implémenté par le plugin Ace
  \item La console, implémentée par le plugin jqconsole
\end{itemize}

\section{Outils utilisés}

%Blabla HTML/CSS/JS, generateur de template twig, Framework bootstrap
%Utilisation de jquery
%Editeur ace
%SweetAlert2 pour les alertes trop swag
%JQConsole vite zef parceque c'est valou qui l'a fait

\subsection{Organisation des templates TWIG}

\section{Environnement de Développement}

\subsection{Gestions des langages}
Blabla DB changement de langage

\subsection{Éditeur de texte}
Tres court parce que y'a pas grand chose à dire

\subsection{Personnalisation}

Toute personne ayant travaillé en groupe sur un projet informatique à pu remarquer que chacun à ces préference de thème pour un éditeur : certains préfere un fond sombre, d'autre un fond clair, etc...
L'éditeur Ace est facilement personnalisable, et dispose par défault de 24 thèmes. Il était donc assez rapide d'implementer à formulaire permettant à l'utilisateur de choisir le thème qui lui convient le mieux,
lui permettant ainsi de facilement s'approprier son outil de travail.

La police est également personnalisable, permettant à chacun d'utiliser une taille de police qui lui convient.

La console ayant un style implementer par le css, il fut de même aisé de créer des thèmes qui s'applique grâce à une classe attribué à l'élement div contenant la console.
Pour l'instant, seul trois style de console sont implémenter, mais il serait aisé d'en ajouté d'autre dans des versions future.
Chaque style a une classe maitresse \emph{.console-nom\_style}, et on redéfini ensuite les classes \emph{jqconsole} grâce aux selecteurs css. Voir le fichier \emph{console.css}.

Tous ces changements sont pour l'instant uniquement gérer en local (voir fichier \emph{options.js}).

\begin{figure}[!h]oir le fichier \emph{console.css}.
\centering
\includegraphics[width=0.8\textwidth]{./img/frontend/example_personnalisation.png}
\caption{Formulaire permettant la personnalisation de l'interface}
\end{figure}

\subsection{Gestions des fichiers}
Tel un véritable EDI, notre application permet la gestion de multiples fichiers. Cette gestion est effectué sur le navigateur, par du javascript.

Les fichiers sont enregistré dans un prototype contenant deux champs : \emph{name}, le nom du fichier, et \emph{content} son contenu. Ces prototype sont ensuite stockés dans la variable
globale \emph{files}, un tableau de fichier. À chaque changement de fichier en cours d'édition, le contenu de l'éditeur est sauvegardé et ensuite remplacé par le contenu du nouveau fichier à éditer.

Les fichiers peuvent être créer de deux façon : soit en important un fichier depuis sont ordinateur (bouton importation), soit par création à partir de modèles défini par l'administrateur pour le langage.
On laisse également la possibilté de créer des fichiers vides (par exemple pour créer un fichier de données utilisé lors de l'éxecution du programme).


\section{Compilation et exécution}

\subsection{Formulaire}


\subsection{Lancement de la compilation et de l'exécution}

Le lancement de la compilation et de l'éxecution du code écris est demandé par l'appuie sur le bouton "Lancer", qui appelle on fonction JS envoyant une requête AJAX
vers la méthode ConsoleController::xecAction (fichier consoleController.php). Cette requête contient le formulaire, qui est ensuite traité : les fichiers vont être écris dans
le système du fichier dans un dossier temporaire, le script de lancement et d'éxecution correspondant au langage est récupérer dans la base de donnée et placer dans ce même répertoire.
Une commande qui va permettre de lancer le docker est ensuite construite. Cette commande va :
\begin{itemize}
  \item Stopper le container de l'utilisateur s'il existe.
  \item{Lancer un container basé sur l'image correspondante au langage, de nom \emph{id\_[id\_user]A}, parametré pour être supprimer à la fin de l'exécution de la commande de lancement. Cette commande de lancement va :
  \begin{itemize}
    \item Récupérer le script de lancement sur le serveur de l'application via un wget
    \item Attribuer les droits d'éxecution sur ce script
    \item Une commande sed remplaçant des caractères indésirable (du à la base de données).
    \item Lancer le script avec les bons paramètres.
  \end{itemize}}
\end{itemize}

Les paramètre du script à lancer sont :
\begin{itemize}
  \item -o 'options\_de\_compilation' pour les paramètres à passer au compilateur
  \item -f 'fichier1 fichier2...'' la liste des fichiers de l'utilisateur (récupérer par un wget).
  \item -i fichier le nom du fichier contenant les inputs si il est necessaire
  \item -n pour un mode non interractif.
  \item -a 'agr0 arg1 ...' les arguments à donner au programme
  \item -c pour uniquement effectuer la compilation
  \item -w 'wget\_adr' l'addresse où effectuer le wget.
\end{itemize}

\subsection{Terminal}

\par La mise en place de la console proposait deux options : soit la création d'une vue ad-hoc soit l'intégration d'une vue déjà existante.

\par Notre choix s'est vite tourné vers l'intégration d'une vue déjà existante. La création d'une vue nous aurait certes donné une modularité de la console en ce qui concerne les modifications mais, la console une fois implémentée n'a pas nécessairement besoin de mofications.

\par Après étude de rentabilité, nous avons décidé d'implémenter la vue JQConsole \footnote{https://github.com/replit/jq-console} qui correspondait exactement à nos besoins. En plus d'être esthétique, son code source était placé sous licence libre et toutes les fonctions qui nous étaient nécessaires étaient déjà implémentées. L'inconvénient principal est que la modification du code source peut se montrer compliqué, celui-ci étant rédigé en CoffeeScript et étant assez compliqué.

\par Nous n'avions donc plus qu'à intégrer la vue JQConsole à notre interface et faire appel aux bonnes fonctions (notamment JQConsole.Write qui permet d'afficher du texte dans la console et JQConsole.Prompt qui permet de lire du texte) pour obtenir notre console.

\section{Problème rencontré et amélioration possible}

\subsection{Rendre l'interface Responsive}
