\chapter{Présentation du projet}

\par Les étudiants arrivant dans le parcours MPCIE à l'UFR Sciences de l'Université d'Angers suivent des cours d'algorithmie au cours de leur premier semeste. Dans le cadre de cet enseignement, ils vont programmer en C++ lors de leur scéance de travaux pratiques. Ceci entraîne un problème lorsque ces étudiants veulent retravailler en dehors des salles du département Informatique : les outils necessaires pour programmer (au minimim un compilateur et un éditeur de texte basique, de préférence un éditeur avancé disposant au moins d'une coloration syntaxique) ne sont pas forcement installé sur leur ordinateurs, et il peut parfois être compliqué d'installer ces outils, ou même impossible si les étudiants souhaitent travailler sur des postes où ils ne sont pas administrateur, comme par exemple à la Bibliothèque Universitaire.
\par De ce fait, il serait interressant de proposer aux étudiants un environnement de développement fonctionnant dans un navigateur web, permettant d'écrire du code dans un éditeur adpaté, puis de l'exécuter sur un serveur distant. De plus, puisque cette application pourrait être utilisé également en scéance de TP, les étudiants retrouverait exactement le même environnement qu'il soit chez eux ou en cours.

\section{Sujet}
%Présentation du sujet : entreprise, encadrement

\par Notre objectif était de réaliser la première version d'un environnement de développement simplifié accessible depuis un navigateur web. Il permet d'écrire et de compiler du code rapidement et simplement sans avoir à installer de compilateur sur le poste client (la compilation s'effectuant sur le serveur). Cet outil pourrait être utilisé, dans le cadre des enseignements à l'Université d'Angers, dans plusieurs unités dès la L1 jusqu'à la L3. \\

\par Certaines caractéristiques nous étaient demandées :

\begin{itemize}

	\item l'édition de code dans un éditeur proposant la coloration syntaxique
	\item la possibilité de compiler le code depuis des compilateurs installés sur le serveur. Le logiciel devra prendre en compte différents langages afin d’être utilisable dans différentes UE
	\item l'accès aux messages d'erreur de la compilation
	\item l'exécution de l'application compilée sur le serveur avec affichage de la sortie
	\item des fonctionnalités avancées devaient être développées telles que l’intégration du débogueur, une gestion plus poussée de l’ensemble de fichiers composant un projet, l'auto-complétion du code, l'intégration d’outils d’analyse

\end{itemize}


\section{Problématique soulevée}

\par L'enjeu principal de ce projet était la sécurité du serveur. En effet, l'application va compiler et exécuter du code inconnu. Il faut d'une part empecher qu'un utilisateur puisse obtenir des accès qu'il ne devrait pas obtenir via, et de plus, il faut gérer les inévitable programme trop gourmands.  En effet, lorsqu'un étudiant tente d'exécuter un programme qui contient des erreurs ou qui demande trop de mémoire CPU, il ne faut pas que le serveur qui gère l'exécution ni les exécutions d'autres étudiants soient ralentis ou bloqués. Il est donc necessaire d'élaborer une architecture visant à repondre à ces problèmatiques.


\section{Choix des principaux outils et technologies}
\label{sec-principaux-outils}
\par Lors de la première séance de concrétisation disciplinaire, nos chefs de projet nous ont proposé d'utiliser le framework Symfony \footnote{Voir \url{https://symfony.com/}}pour la réalisation de notre application. Ce framework force à organiser le code et permet une gestion simple de la base de données qui ne dépend pas du type de celle-ci. En effet, Symfony intègre la bibliothèqe Doctrine\footnote{Plus de détail sur \url{http://www.doctrine-project.org/}}, facilitant la manipulation de base de donnée et permettant le mapping d'une base de données relationnelle avec des objets PHP. De plus, Symfony permet une génération simple des pages grâce à ses controllers et au moteur de template twig. Le dernier point important nous ayant pousser à utiliser Symfony est la possibilité d'utiliser des bundles (par exemple, FOSUserBundle permet la gestion des utilisateurs) qui simplifient et accélèrent véritablement la réalisation des projets.

\par Nous avons choisi d'utiliser MariaDB comme système de base de données. MariaDB est un des système de gestion de base de données le plus important, et est a l'avantage d'être distribué sous license libre. De plus, cet outils est soutenue par un large communauté, ce qui assure une maintenance sur le long terme. Néanmoins, ce SGBD peut facilement être remplacé par un autre si besoin, puisque toutes les manipulation de base de données se font via l'ORM\footnote{Object-Relationnal Mapping} de Symfony. Le seul pré-requis que le SGBD soit supporter par Doctrine.

\par Bootstrap\footnote{Voir \url{https://getbootstrap.com/}} est un framework HTML/CSS/JS, facile à utliser. Bootstrap utilise un layout sous la forme d'une grille, qui s'adapte en fonction de la taille de l'écran. De plus, Bootstrap inclu un style de base pour tous les éléments HTML, ce qui permet d'avoir un style indépendant du navigateur ou de l'OS utilisé pr l'utilisateur. Ce style peut également être modifié via des constantes SASS si on veut aller plus loin dans la personnalisation de l'application. Enfin, Bootstrap inclu de nombreux composnt facile à manipuler via des attributs HTML (ou le JS) tel que les dropdowns, modals, alert... Pour toute ces raisons, nous avons choisi d'utiliser ce framework pour notre interface après qu'il nous ait été conseillé par nos chefs de projet.

\par La conteneurisation, et plus particulièrement Docker\footnote{\url{https://www.docker.com/}}, s'est vite imposée dans l'architecture du serveur. Docker est une méthode de conteneurisation légère qui permet de travailler toujours sur le même environnement (la même image est réutilisée autant de fois que nécessaire) et qui nous a permis d'isoler les compilations et exécutions des programmes.

\section{Répartition des tâches}

\par Afin de travailler efficacement, nous avons séparé le projet en 4 parties plus ou moins autonomes: Paulin s'est occupé de l'interface graphique, Yassine de l'administration, Jérôme de l'architecture du serveur et Valentine de la communication entre les serveurs.

\subsection{Planning}

Faire le planning
