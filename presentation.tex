\chapter{Présentation du projet}

\par Dans le cadre des enseignements d'algorithmie proposés par l'Université d'Angers pour le pacours MPCIE, les étudiants vont apprendre à programmer avec différents langages. Un problème peut apparaître lorsque ces étudiants souhaitent retravailler leurs exercices sur d'autres postes que ceux du département informatique; les outils nécessaires pour programmer (a minima un compilateur et un éditeur de texte) ne seront pas systématiquement installés sur les ordinateurs et leurs installations peuvent se montrer compliquées voire impossibles si les droits d'administrateurs ne sont pas attribués à l'utilisateur (c'est le cas sur les postes de la bibliothèque universitaire, par exemple).

\par De ce fait, l'Université d'Angers a souhaité proposer à ses étudiants un environnement de développement en ligne qui leur permettrait d'écrire et de compiler du code simplement et sans installation préalable.

\par Aussi, cette application pourrait être utilisée lors des séances de travaux pratiques, ce qui permettrait aux étudiants de retrouver l'environnement qu'ils utilisent chez eux.


\section{Sujet}
%Présentation du sujet : entreprise, encadrement

\par Notre objectif était de réaliser la première version d'un environnement de développement simplifié accessible depuis un navigateur web. Il devait permettre d'écrire et de compiler du code rapidement et simplement sans avoir à installer de compilateur sur le poste client (la compilation s'effectuant sur le serveur). Cet outil pourrait être utilisé, dans le cadre des enseignements à l'Université d'Angers, dans plusieurs unités dès la L1 jusqu'à la L3 (voire jusqu'au master). \\

\par Certaines caractéristiques nous étaient demandées :

\begin{itemize}

	\item l'édition de code dans un éditeur proposant la coloration syntaxique
	\item la possibilité de compiler le code depuis des compilateurs installés sur le serveur. Le logiciel devait prendre en compte différents langages afin d’être utilisable dans différentes UE
	\item l'accès aux messages d'erreur de la compilation
	\item l'exécution de l'application compilée sur le serveur avec affichage de la sortie
	\item des fonctionnalités avancées devaient être développées telles que l’intégration du débogueur, une gestion plus poussée de l’ensemble de fichiers composant un projet, l'auto-complétion du code, l'intégration d’outils d’analyse

\end{itemize}


\section{Problématique soulevée}

\par L'enjeu principal de ce projet était la sécurité du serveur. En effet, l'application va compiler et exécuter du code inconnu. Il faut d'une part empecher qu'un utilisateur puisse obtenir des accès qu'il ne devrait pas obtenir via, et de plus, il faut gérer les inévitable programme trop gourmands.  En effet, lorsqu'un étudiant tente d'exécuter un programme qui contient des erreurs ou qui demande trop de mémoire CPU, il ne faut pas que le serveur qui gère l'exécution ni les exécutions d'autres étudiants soient ralentis ou bloqués. Il est donc necessaire d'élaborer une architecture visant à repondre à ces problèmatiques.


\section{Choix des principaux outils et technologies}
\label{sec-principaux-outils}
\par Lors de la première séance de concrétisation disciplinaire, nos chefs de projet nous ont proposé d'utiliser le framework Symfony \footnote{Voir \url{https://symfony.com/}}pour la réalisation de notre application. Ce framework force à organiser le code et permet une gestion simple de la base de données qui ne dépend pas du type de celle-ci. En effet, Symfony intègre la bibliothèque Doctrine\footnote{Plus de détails sur \url{http://www.doctrine-project.org/}}, facilitant la manipulation de bases de données et permettant le mapping d'une base de données relationnelle avec des objets PHP. De plus, Symfony permet une génération simple des pages grâce à ses controllers et au moteur de template twig. Le dernier point important nous ayant poussé à utiliser Symfony est la possibilité d'utiliser des bundles (par exemple, FOSUserBundle permet la gestion des utilisateurs) qui simplifient et accélèrent véritablement la réalisation des projets.

\par Nous avons choisi d'utiliser MariaDB comme système de base de données. MariaDB est l'un des systèmes de gestion de base de données les plus importants, et a l'avantage d'être distribué sous licence libre. De plus, cet outil est soutenu par une large communauté, ce qui assure une maintenance sur le long terme. Néanmoins, ce SGBD peut facilement être remplacé par un autre si besoin, puisque toutes les manipulations de base de données se font via l'ORM\footnote{Object-Relationnal Mapping} de Symfony. Le seul pré-requis est que le SGBD soit supporter par Doctrine.

\par Bootstrap\footnote{Voir \url{https://getbootstrap.com/}} est un framework HTML/CSS/JS simple d'utilisation. Bootstrap utilise un layout sous la forme d'une grille qui s'adapte en fonction de la taille de l'écran. De plus, il inclut un style de base pour tous les éléments HTML, ce qui permet d'obtenir un style indépendant du navigateur ou de l'OS utilisé par l'utilisateur. Ce style peut également être modifié via des constantes SASS\footnote{Syntactically Awesome Stylesheets} si on souhaite aller plus loin dans la personnalisation de l'application. 
\par Enfin, Bootstrap inclut de nombreux composants faciles à manipuler via des attributs HTML (ou le JS) tels que les dropdowns, modals, alert... Pour toutes ces raisons, nous avons choisi d'utiliser ce framework pour notre interface après qu'il nous ait été conseillé par nos chefs de projet.

\par La conteneurisation, et plus particulièrement Docker\footnote{\url{https://www.docker.com/}}, s'est vite imposée dans l'architecture du serveur. Docker est une méthode de conteneurisation légère qui permet de travailler toujours sur le même environnement (la même image est réutilisée autant de fois que nécessaire) et qui nous a permis d'isoler les compilations et exécutions des programmes.

\section{Répartition des tâches}

\par Afin de travailler efficacement, nous avons séparé le projet en 4 parties plus ou moins autonomes: Paulin s'est occupé de l'interface graphique, Yassine de l'administration, Jérôme de l'architecture du serveur et Valentine de la communication entre les serveurs.

\subsection{Planning}

Faire le planning
